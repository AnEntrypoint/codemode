#!/usr/bin/env node

const { existsSync, readFileSync, writeFileSync, mkdirSync, readdirSync, statSync } = require('fs');
const { join, resolve, dirname, basename } = require('path');
const { spawn } = require('child_process');
const fg = require('fast-glob');

const workingDirectory = process.env.CODEMODE_WORKING_DIR || process.cwd();

function Read(file_path, offset = 0, limit = null) {
  const absPath = resolve(workingDirectory, file_path);
  if (!existsSync(absPath)) {
    throw new Error(`File not found: ${absPath}`);
  }
  let content = readFileSync(absPath, 'utf8');
  if (content === '') {
    return `<system-reminder>File exists but has empty contents: ${absPath}</system-reminder>`;
  }
  const lines = content.split('\n');
  const start = offset || 0;
  const defaultLimit = 2000;
  const end = limit ? start + limit : Math.min(start + defaultLimit, lines.length);
  const selectedLines = lines.slice(start, end);
  const numberedLines = selectedLines.map((line, index) => {
    const lineNum = start + index + 1;
    const truncatedLine = line.length > 2000 ? line.substring(0, 2000) : line;
    return `${lineNum.toString().padStart(5)}â†’${truncatedLine}`;
  });
  let result = numberedLines.join('\n');
  if (result.length > 30000) {
    result = result.substring(0, 30000);
  }
  return result;
}

function Write(file_path, content) {
  const absPath = resolve(workingDirectory, file_path);
  const fileExists = existsSync(absPath);
  if (fileExists) {
    const existingContent = readFileSync(absPath, 'utf8');
    if (existingContent === content) {
      return `File unchanged: ${absPath} (content is identical)`;
    }
  }
  const dir = dirname(absPath);
  if (!existsSync(dir)) {
    mkdirSync(dir, { recursive: true });
  }
  writeFileSync(absPath, content, 'utf8');
  const action = fileExists ? 'overwrote' : 'created';
  return `Successfully ${action} file: ${absPath}`;
}

function Edit(file_path, old_string, new_string, replace_all = false) {
  const absPath = resolve(workingDirectory, file_path);
  if (!existsSync(absPath)) {
    throw new Error(`File not found: ${absPath}`);
  }
  if (old_string === new_string) {
    return 'No changes made: old_string and new_string are identical';
  }
  let content = readFileSync(absPath, 'utf8');
  const originalContent = content;
  if (replace_all) {
    if (!content.includes(old_string)) {
      throw new Error(`String not found in file: ${old_string}`);
    }
    content = content.split(old_string).join(new_string);
  } else {
    const index = content.indexOf(old_string);
    if (index === -1) {
      throw new Error(`String not found in file: ${old_string}`);
    }
    content = content.substring(0, index) + new_string + content.substring(index + old_string.length);
  }
  if (content !== originalContent) {
    writeFileSync(absPath, content, 'utf8');
  }
  const action = replace_all ? 'replaced all occurrences' : 'replaced';
  return `Successfully ${action} in file: ${absPath}`;
}

async function Glob(pattern, path = null) {
  const cwd = path ? resolve(workingDirectory, path) : workingDirectory;
  const files = await fg(pattern, {
    cwd,
    absolute: false,
    dot: true,
    onlyFiles: true,
    stats: true
  });
  const sortedFiles = files
    .sort((a, b) => b.stats.mtimeMs - a.stats.mtimeMs)
    .map(entry => typeof entry === 'string' ? entry : entry.path);
  let result = sortedFiles.length > 0 ? sortedFiles.join('\n') : 'No files matched';
  if (result.length > 30000) {
    result = result.substring(0, 30000);
  }
  return result;
}

function Grep(pattern, path = '.', options = {}) {
  return new Promise((resolve, reject) => {
    const searchPath = require('path').resolve(workingDirectory, path);
    const rgArgs = [pattern, searchPath];
    if (options.glob) rgArgs.push('--glob', options.glob);
    if (options.type) rgArgs.push('--type', options.type);
    if (options['-i']) rgArgs.push('--ignore-case');
    if (options['-n']) rgArgs.push('--line-number');
    if (options.multiline) rgArgs.push('--multiline');
    if (options['-B']) rgArgs.push('--before-context', options['-B'].toString());
    if (options['-A']) rgArgs.push('--after-context', options['-A'].toString());
    if (options['-C']) rgArgs.push('--context', options['-C'].toString());
    const output_mode = options.output_mode || 'files_with_matches';
    if (output_mode === 'files_with_matches') {
      rgArgs.push('--files-with-matches');
    } else if (output_mode === 'count') {
      rgArgs.push('--count');
    }
    const child = spawn('rg', rgArgs);
    let output = '';
    let errorOutput = '';
    child.stdout.on('data', (data) => { output += data.toString(); });
    child.stderr.on('data', (data) => { errorOutput += data.toString(); });
    child.on('close', (code) => {
      if (code !== 0 && errorOutput && !errorOutput.includes('No matches found')) {
        reject(new Error(`Grep search error: ${errorOutput}`));
        return;
      }
      let result = output.trim();
      if (options.head_limit) {
        const lines = result.split('\n');
        result = lines.slice(0, options.head_limit).join('\n');
      }
      if (result.length > 30000) {
        result = result.substring(0, 30000);
      }
      resolve(result || 'No matches found');
    });
  });
}

function Bash(command, description = '', timeout = 120000) {
  return new Promise((resolve, reject) => {
    if (timeout > 600000) {
      reject(new Error('Timeout cannot exceed 600000ms (10 minutes)'));
      return;
    }
    if (command.includes('rm -rf /') || command.includes('sudo rm')) {
      reject(new Error('Dangerous command detected'));
      return;
    }
    const child = spawn(command, [], {
      shell: true,
      timeout,
      cwd: workingDirectory,
      env: { ...process.env, TERM: 'xterm-256color' }
    });
    let stdout = '';
    let stderr = '';
    child.stdout.on('data', (data) => { stdout += data.toString(); });
    child.stderr.on('data', (data) => { stderr += data.toString(); });
    child.on('close', (code) => {
      let output = stdout || stderr;
      const prefix = description ? `[${description}] ` : '';
      if (output.length > 30000) {
        output = output.substring(0, 30000);
      }
      if (code === 0) {
        resolve(`${prefix}${output}`);
      } else {
        reject(new Error(`${prefix}${output}`));
      }
    });
    child.on('error', (error) => {
      reject(new Error(`Command execution error: ${error.message}`));
    });
  });
}

function LS(path = '.', show_hidden = false, recursive = false) {
  const absPath = resolve(workingDirectory, path);
  if (!existsSync(absPath)) {
    throw new Error(`Path not found: ${absPath}`);
  }
  const stats = statSync(absPath);
  if (!stats.isDirectory()) {
    return `${basename(absPath)} (${stats.size} bytes)`;
  }
  function listDirectory(dirPath, prefix = '') {
    const entries = readdirSync(dirPath);
    const result = [];
    for (const entry of entries) {
      if (!show_hidden && entry.startsWith('.')) {
        continue;
      }
      const fullPath = join(dirPath, entry);
      const stats = statSync(fullPath);
      const isDir = stats.isDirectory();
      const size = isDir ? '' : ` (${stats.size} bytes)`;
      const type = isDir ? '/' : '';
      result.push(`${prefix}${entry}${type}${size}`);
      if (recursive && isDir) {
        result.push(...listDirectory(fullPath, prefix + '  '));
      }
    }
    return result;
  }
  const listing = listDirectory(absPath);
  let result = listing.length > 0 ? listing.join('\n') : 'Empty directory';
  if (result.length > 30000) {
    result = result.substring(0, 30000);
  }
  return result;
}

async function main() {
  let input = '';
  process.stdin.on('data', (chunk) => {
    input += chunk.toString();
  });

  process.stdin.on('end', async () => {
    try {
      const request = JSON.parse(input);
      const { action, ...args } = request;

      let result;
      switch (action) {
        case 'read':
          result = Read(args.path, args.offset, args.limit);
          break;
        case 'write':
          result = Write(args.path, args.content);
          break;
        case 'edit':
          result = Edit(args.path, args.old_string, args.new_string, args.replace_all);
          break;
        case 'glob':
          result = await Glob(args.pattern, args.path);
          break;
        case 'grep':
          result = await Grep(args.pattern, args.path, args.options || {});
          break;
        case 'bash':
          result = await Bash(args.command, args.description, args.timeout);
          break;
        case 'ls':
          result = LS(args.path, args.show_hidden, args.recursive);
          break;
        default:
          throw new Error(`Unknown action: ${action}`);
      }

      console.log(JSON.stringify({ success: true, result }));
      process.exit(0);
    } catch (error) {
      console.log(JSON.stringify({ success: false, error: error.message }));
      process.exit(1);
    }
  });
}

if (require.main === module) {
  main();
}

module.exports = { Read, Write, Edit, Glob, Grep, Bash, LS };
